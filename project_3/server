#!/usr/bin/env python

import sys, glob
import hashlib, time, socket

sys.path.append('gen-py')
sys.path.insert(0,glob.glob('/home/yaoliu/src_code/thrift/lib/py/build/lib.*')[0])

from chord_join_remove_dht import FileStore


from chord_join_remove_dht.ttypes import *

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer







ownerMeta = {"":[]}
ownerFileMeta = {}
port_num = sys.argv[1]
fingertable = [None]*256
  
  

myIP = socket.gethostbyname(socket.gethostname())
ip_port = myIP + ":" + port_num
sha256 = hashlib.sha256()
sha256.update(ip_port)
myID = sha256.hexdigest()

myNode = NodeID(myID,myIP,port_num,0)
existing_nodes = []
pred = NodeID("0","0",0,0)
succ = NodeID("0","0",0,0)

port_num = sys.argv[1]
def hexStr_to_int(hex_str):
  return int(hex_str,16)

def int_to_hexStr(num):
  string = str(num).lstrip('0x')
  string = string.rstrip('L')
  return string

class FileStoreHandler:
  ownerMeta = {"":[]}
  ownerFileMeta = {}
  port_num = sys.argv[1]
  fingertable = [None]*256
  
  

  myIP = socket.gethostbyname(socket.gethostname())
  ip_port = myIP + ":" + port_num
  sha256 = hashlib.sha256()
  sha256.update(ip_port)
  myID = sha256.hexdigest()

  myNode = NodeID(myID,myIP,port_num,0)
  existing_nodes = []
  pred = NodeID("0","0",0,0)
  succ = NodeID("0","0",0,0)

  def __init__(self):
    self.log = {}
    self.fingertable = fingertable
    self.myIP = myIP
    self.myID = myID
    self.myNode = myNode
    self.pred = pred
    self.existing_nodes = existing_nodes



  def listOwnedFiles(self, user):
    return self.ownerMeta[user]     


  def writeFile(self, rFile):
    index = rFile.meta.owner,rFile.meta.filename
    h = hashlib.sha256(rFile.content)
    h = str(h.hexdigest())
    
    

    if index in self.ownerFileMeta:
      #filename
      fname = self.ownerFileMeta[index].meta.filename
    
      #created
      created = self.ownerFileMeta[index].meta.created

      #updated
      updated = time.time()

      #deleted
      deleted = self.ownerFileMeta[index].meta.deleted      

      #version
      version = self.ownerFileMeta[index].meta.version + 1

      #owner
      owner = self.ownerFileMeta[index].meta.owner

      #content length
      contentLength = self.ownerFileMeta[index].meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      name = index[0]
      self.ownerFileMeta[index] = r
      self.ownerMeta[name].append(ownerFileMeta[index].meta)

    else:
       #filename
      fname = rFile.meta.filename
    
      #created
      created = time.time()

      #updated
      updated = time.time()

      #deleted
      deleted = rFile.meta.deleted      

      #version
      version = 0

      #owner
      owner = rFile.meta.owner

      #content length
      contentLength = rFile.meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      self.ownerFileMeta[index] = r
      
      name = index[0]
      if name not in self.ownerMeta:
        self.ownerMeta[name] = [m]
      else:
        self.ownerMeta[name].append(m)

  def readFile(self, filename, owner):
    index = owner, filename
    if index in self.ownerFileMeta:
      r = self.ownerFileMeta[index]
      return r
    else:
      raise SystemException()
      return "Error"




  def deleteFile(self, filename, owner):
    index = owner, filename
    if index in self.ownerFileMeta:
      self.ownerFileMeta[index].meta.deleted = time.time()
      del self.ownerFileMeta[index]
      for m in self.ownerMeta[owner]:
        if m.filename == filename:
          self.ownerMeta[owner].remove(m)

    else:
      raise SystemException()
    
  


  def isPred(self, lower_bound, key, upper_bound):
    ## crossover cases
    if (upper_bound < lower_bound) and (key >= lower_bound):
      return True
    elif (upper_bound < lower_bound) and (key <= upper_bound):
      return True     
    ##

    elif (upper_bound > lower_bound) and (key >= lower_bound) and (key <= upper_bound):
      return True
    else:
      return False
       


    


  def setFingertable(self, node_list):
    for node in node_list:
      self.fingertable.append(node)
      


  def findPred(self, key):

    #If key exists btwn current node and successor(current node)
    if (self.myID <= key) and (key <= self.fingertable[0].id):
      n = NodeID(self.myID,myIP, int(port_num))
      return n

    #If pred exists in fingertable
    for node in range(len(self.fingertable)-2):
      if self.isPred(self.fingertable[node].id, key, self.fingertable[node+1].id) == True:
        return self.fingertable[node]

    #recursively find pred if key is beyond scope of fingers
    if key > self.fingertable[-1].id:    
      transport = TSocket.TSocket(self.fingertable[-1].ip,self.fingertable[-1].port)
      transport = TTransport.TBufferedTransport(transport)
  
      # Wrap in a protocol
      protocol = TBinaryProtocol.TBinaryProtocol(transport)
      # Create a client to use the protocol encoder
      client = FileStore.Client(protocol)
      # Connect!
      transport.open()
      print key
      pred = client.findPred(key)
      print "THIS IS PRED!" + pred
      transport.close()
      #return pred



  




  def getNodeSucc(self):
    return self.fingertable[0]
 
  def findSucc(self, key):
    
    pred = self.findPred(key)

    transport = TSocket.TSocket(pred.ip,pred.port)
    transport = TTransport.TBufferedTransport(transport)
    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    # Create a client to use the protocol encoder
    client = FileStore.Client(protocol)
    # Connect!
    transport.open()
    succ = client.getNodeSucc()
    return succ 
      
  def updateFinger(self, idx, nodeId):
    print "index is " + str(idx)
    self.fingertable[idx] = nodeId

  def pullUnownedFiles(self):
    return 0
  def pushUnownedFiles(self):
    return 0  



  def join(self, nodeID):
    #ask arbitrary node to set pred, and fingertable
    if nodeID in self.existing_nodes:
      
      self.pred = nodeID.findPred(self.myID)
      for i in range(256):
        self.updateFinger(i,nodeID.findSucc(int_to_hexStr(hexStr_to_int(self.myID)+2**i)))
      
    else:
      #first node in network
      for i in range(256):
        self.updateFinger(i,self.myNode)
      self.pred = self.myNode

      print self.fingertable







  def leave(self):
    return 0
     


  
handler = FileStoreHandler()
processor = FileStore.Processor(handler)
transport = TSocket.TServerSocket(port=port_num)
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()

server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)

# You could do one of these for a multithreaded server
#server = TServer.TThreadedServer(processor, transport, tfactory, pfactory)
#server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)
transport.close()
print 'Starting the server...'
server.serve()
print 'done.'
