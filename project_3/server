#!/usr/bin/env python

import sys, glob
import hashlib, time, socket

sys.path.append('gen-py')
sys.path.insert(0,glob.glob('/home/yaoliu/src_code/thrift/lib/py/build/lib.*')[0])

from chord_join_remove_dht import FileStore


from chord_join_remove_dht.ttypes import *

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer




fingertable = [None]*256
myIP = socket.gethostbyname(socket.gethostname())
port_num = sys.argv[1]
ip_port = self.myIP + ":" + self.port_num


sha256 = hashlib.sha256()
sha256.update(self.ip_port)
myID = sha256.hexdigest()
myID = myID
myNode = NodeID(self.myID,self.myIP,int(self.port_num),0)
ownerFileMeta = {}
ownerMeta = {"":[]}
count = 0
for i in range(256):
  self.updateFinger(i,self.myNode)
pred = myNode
for i in range(256):
  print self.fingertable[i].port



def hexStr_to_int(hex_str):
  return int(hex_str,16)

def int_to_hexStr(num):
  string = str(num).lstrip('0x')
  string = string.rstrip('L')
  return string

class FileStoreHandler:
  
  def __init__(self):
    self.log = {}
    

  def listOwnedFiles(self, user):
    return self.ownerMeta[user]     


  def writeFile(self, rFile):
    index = rFile.meta.owner,rFile.meta.filename
    h = hashlib.sha256(rFile.content)
    h = str(h.hexdigest())
    
    

    if index in self.ownerFileMeta:
      #filename
      fname = self.ownerFileMeta[index].meta.filename
    
      #created
      created = self.ownerFileMeta[index].meta.created

      #updated
      updated = time.time()

      #deleted
      deleted = self.ownerFileMeta[index].meta.deleted      

      #version
      version = self.ownerFileMeta[index].meta.version + 1

      #owner
      owner = self.ownerFileMeta[index].meta.owner

      #content length
      contentLength = self.ownerFileMeta[index].meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      name = index[0]
      self.ownerFileMeta[index] = r
      self.ownerMeta[name].append(ownerFileMeta[index].meta)

    else:
       #filename
      fname = rFile.meta.filename
    
      #created
      created = time.time()

      #updated
      updated = time.time()

      #deleted
      deleted = rFile.meta.deleted      

      #version
      version = 0

      #owner
      owner = rFile.meta.owner

      #content length
      contentLength = rFile.meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      self.ownerFileMeta[index] = r
      
      name = index[0]
      if name not in self.ownerMeta:
        self.ownerMeta[name] = [m]
      else:
        self.ownerMeta[name].append(m)

  def readFile(self, filename, owner):
    index = owner, filename
    if index in self.ownerFileMeta:
      r = self.ownerFileMeta[index]
      return r
    else:
      raise SystemException()
      return "Error"




  def deleteFile(self, filename, owner):
    index = owner, filename
    if index in self.ownerFileMeta:
      self.ownerFileMeta[index].meta.deleted = time.time()
      del self.ownerFileMeta[index]
      for m in self.ownerMeta[owner]:
        if m.filename == filename:
          self.ownerMeta[owner].remove(m)

    else:
      raise SystemException()
    
  


  def isPred(self, lower_bound, key, upper_bound):
    ## crossover cases
    if (upper_bound < lower_bound) and (key >= lower_bound):
      return True
    elif (upper_bound < lower_bound) and (key <= upper_bound):
      return True     
    ##

    elif (upper_bound > lower_bound) and (key >= lower_bound) and (key <= upper_bound):
      return True
    else:
      return False
       
      


  def findPred(self, key):

    #If key exists btwn current node and successor(current node)
    if (self.myID <= key) and (key <= self.fingertable[0].id):
      n = self.myNode
      return n

    #If pred exists in fingertable
    for node in range(len(self.fingertable)-2):
      if self.isPred(self.fingertable[node].id, key, self.fingertable[node+1].id) == True:
        return self.fingertable[node]

    #recursively find pred if key is beyond scope of fingers
    if key > self.fingertable[-1].id:    
      transport = TSocket.TSocket(self.fingertable[-1].ip,self.fingertable[-1].port)
      transport = TTransport.TBufferedTransport(transport)
  
      # Wrap in a protocol
      protocol = TBinaryProtocol.TBinaryProtocol(transport)
      # Create a client to use the protocol encoder
      client = FileStore.Client(protocol)
      # Connect!
      transport.open()
      print key
      pred = client.findPred(key)
      print "THIS IS PRED!" + pred
      transport.close()
      #return pred



  




  def getNodeSucc(self):
    return self.fingertable[0]
 
  def findSucc(self, key):
    
    pred = self.findPred(key)

    transport = TSocket.TSocket(pred.ip,pred.port)
    transport = TTransport.TBufferedTransport(transport)
    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    # Create a client to use the protocol encoder
    client = FileStore.Client(protocol)
    # Connect!
    transport.open()
    succ = client.getNodeSucc()
    return succ 
      
  def updateFinger(self, idx, nodeId):
    self.fingertable[idx] = nodeId

  def pullUnownedFiles(self):
    return 0
  def pushUnownedFiles(self):
    return 0  



  def join(self, nodeID):
    #set fingertable

    for i in range(256):
      self.updateFinger(i,nodeID.findSucc(int_to_hexStr(hexStr_to_int(self.myID)+2**i)))
    #ask arbitrary node to set pred, and fingertable
    self.pred = self.findPred(self.myID)

    #check affected fingertables    
    start = self.findPred(myID)
    while(start != self):
      for i in range(256):
        if hexStr_to_int(p.fingertable[i]) in xrange(hexStr_to_int(self.pred.id)+1, hexStr_to_int(self.myID)+1):
          p.fingertable[i] = self.myNode

    


          





    print str(self.count) + " NEW NODES IN THE NETWORK"




  def leave(self):
    return 0
    


  
handler = FileStoreHandler()
processor = FileStore.Processor(handler)
transport = TSocket.TServerSocket(port=sys.argv[1])
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()
server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)




# You could do one of these for a multithreaded server
#server = TServer.TThreadedServer(processor, transport, tfactory, pfactory)
#server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)
transport.close()
print 'Starting the server...'
server.serve()
print 'done.'
