#!/usr/bin/env python
#YO
import sys, glob
import hashlib, time, socket

sys.path.append('gen-py')
sys.path.insert(0,glob.glob('/home/yaoliu/src_code/thrift/lib/py/build/lib.*')[0])

from chord_join_remove_dht import FileStore


from chord_join_remove_dht.ttypes import *

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer




fingertable = [None]*256
myIP = socket.gethostbyname(socket.gethostname())
port_num = sys.argv[1]
ip_port = myIP + ":" + port_num
succ = None

sha256 = hashlib.sha256()
sha256.update(ip_port)
myID = sha256.hexdigest()
myID = myID
myNode = NodeID(myID,myIP,int(port_num),0)
ownerFileMeta = {}
ownerMeta = {"":[]}
count = 0
for i in range(256):
  fingertable[i] = myNode
pred = myNode


print myNode.port
print myNode.ip
def isPred(self, lower_bound, key, upper_bound):
    ## crossover cases
    if (upper_bound < lower_bound) and (key >= lower_bound):
      return True
    elif (upper_bound < lower_bound) and (key <= upper_bound):
      return True     
    ##

    elif (upper_bound > lower_bound) and (key >= lower_bound) and (key <= upper_bound):
      return True
    else:
      return False

def hexStr_to_int(hex_str):
  return int(hex_str,16)

def int_to_hexStr(num):
  string = str(hex(num)).lstrip('0x')
  string = string.rstrip('L')
  return string

class FileStoreHandler:
  
  def __init__(self):
    self.log = {}
    

  def listOwnedFiles(self, user):
    return ownerMeta[user]     


  def writeFile(self, rFile):
    index = rFile.meta.owner,rFile.meta.filename
    h = hashlib.sha256(rFile.content)
    h = str(h.hexdigest())
    
    

    if index in ownerFileMeta:
      #filename
      fname = ownerFileMeta[index].meta.filename
    
      #created
      created = ownerFileMeta[index].meta.created

      #updated
      updated = time.time()

      #deleted
      deleted = ownerFileMeta[index].meta.deleted      

      #version
      version = ownerFileMeta[index].meta.version + 1

      #owner
      owner = ownerFileMeta[index].meta.owner

      #content length
      contentLength = ownerFileMeta[index].meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      name = index[0]
      ownerFileMeta[index] = r
      ownerMeta[name].append(ownerFileMeta[index].meta)

    else:
       #filename
      fname = rFile.meta.filename
    
      #created
      created = time.time()

      #updated
      updated = time.time()

      #deleted
      deleted = rFile.meta.deleted      

      #version
      version = 0

      #owner
      owner = rFile.meta.owner

      #content length
      contentLength = rFile.meta.contentLength

      #hash
      contentHash = h
    
      m = RFileMetadata(fname, created, updated, deleted, version, owner, contentLength, contentHash)
      c = rFile.content
      r = RFile(m,c)
      ownerFileMeta[index] = r
      
      name = index[0]
      if name not in ownerMeta:
        ownerMeta[name] = [m]
      else:
        ownerMeta[name].append(m)

  def readFile(self, filename, owner):
    index = owner, filename
    if index in ownerFileMeta:
      r = ownerFileMeta[index]
      return r
    else:
      raise SystemException()
      return "Error"




  def deleteFile(self, filename, owner):
    index = owner, filename
    if index in ownerFileMeta:
      ownerFileMeta[index].meta.deleted = time.time()
      del ownerFileMeta[index]
      for m in ownerMeta[owner]:
        if m.filename == filename:
          ownerMeta[owner].remove(m)

    else:
      raise SystemException()
    
  


  def isPred(self, lower_bound, key, upper_bound):
    ## crossover cases
    if (upper_bound < lower_bound) and (key >= lower_bound):
      return True
    elif (upper_bound < lower_bound) and (key <= upper_bound):
      return True     
    ##

    elif (upper_bound > lower_bound) and (key >= lower_bound) and (key <= upper_bound):
      return True
    else:
      return False
       
      


  def findPred(self, key):
    #If key exists btwn current node and successor(current node)

    same = fingertable[0];

    only_one = True
    for x in range(256):
      if fingertable[x].id != same.id:
        only_one = False

    if only_one: 
      return myNode

    if (myID <= key) and (key <= fingertable[0].id):
      return myNode

    #If pred exists in fingertable
    for node in range(len(fingertable)-2):
      if isPred(fingertable[node].id, key, fingertable[node+1].id) == True:
        return fingertable[node]

    #recursively find pred if key is beyond scope of fingers
    if key > fingertable[-1].id:    
      transport = TSocket.TSocket(fingertable[-1].ip,fingertable[-1].port)
      transport = TTransport.TBufferedTransport(transport)
  
      # Wrap in a protocol
      protocol = TBinaryProtocol.TBinaryProtocol(transport)
      # Create a client to use the protocol encoder
      client = FileStore.Client(protocol)
      # Connect!
      transport.open()
      pred = client.findPred(key)
      transport.close()
      return pred



  




  def getNodeSucc(self):
    return fingertable[0]
 
  def findSucc(self, key):
    pred = self.findPred(key)
    if pred.id != myID:
      
      transport = TSocket.TSocket(pred.ip,pred.port)
      transport = TTransport.TBufferedTransport(transport)
      protocol = TBinaryProtocol.TBinaryProtocol(transport)
      client = FileStore.Client(protocol)
      transport.open()
      succ = client.getNodeSucc()
      transport.close()
      return succ
    else:
      succ = self.getNodeSucc()
    return succ


      
    
      
  def getFingertable(self):
    return fingertable
      
  def setNodePred(self,nodeId):
    pred = nodeId

  def updateFinger(self, idx, nodeId):
    fingertable[idx] = nodeId

  def pullUnownedFiles(self):
    return 0
  def pushUnownedFiles(self):
    return 0  



  def join(self, nodeID):
    # Make socket
    transport = TSocket.TSocket(nodeID.ip, nodeID.port)
    # Buffering is critical. Raw sockets are very slow
    transport = TTransport.TBufferedTransport(transport)
    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    # Create a client to use the protocol encoder
    client = FileStore.Client(protocol)
    # Connect!
    transport.open()
    for i in range(256):
      n = int_to_hexStr(hexStr_to_int(myID)+(2**i))
      self.updateFinger(i,client.findSucc(n))
    transport.close()

    transport = TSocket.TSocket(fingertable[0].ip, fingertable[0].port)
    # Buffering is critical. Raw sockets are very slow
    transport = TTransport.TBufferedTransport(transport)
    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    # Create a client to use the protocol encoder
    client = FileStore.Client(protocol)
    # Connect!

    #set pred's
    start = nodeID
    transport.open()
      while(start.id != myID):



    transport.close()




    pred = self.setNodePred(nodeID.id)
    nodeID.pred = self.findPred(nodeID.id)
    start = nodeID


    
    #check affected fingertables    
    while(start.id != myID):
      for i in range(256):
        if hexStr_to_int(start.fingertable[i]) in xrange(hexStr_to_int(pred.id)+1, hexStr_to_int(myID)+1):
          transport = TSocket.TSocket(start.ip,start.port)
          transport = TTransport.TBufferedTransport(transport)
          protocol = TBinaryProtocol.TBinaryProtocol(transport)
          client = FileStore.Client(protocol)
          transport.open()
          client.updateFinger(i, myNode)
          transport.close()
      start = start.pred
    print fingertable








   

          





    print str(count) + " NEW NODES IN THE NETWORK"




  def leave(self):
    return 0
    


  
handler = FileStoreHandler()
processor = FileStore.Processor(handler)
transport = TSocket.TServerSocket(port=sys.argv[1])
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()
server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)




# You could do one of these for a multithreaded server
#server = TServer.TThreadedServer(processor, transport, tfactory, pfactory)
#server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)
transport.close()
print 'Starting the server...'
server.serve()
print 'done.'
